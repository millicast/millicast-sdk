<!DOCTYPE html><html lang="en" style="font-size:16px"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Source: View.js</title><!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><script src="scripts/third-party/hljs.js" defer="defer"></script><script src="scripts/third-party/hljs-line-num.js" defer="defer"></script><script src="scripts/third-party/popper.js" defer="defer"></script><script src="scripts/third-party/tippy.js" defer="defer"></script><script src="scripts/third-party/tocbot.min.js"></script><script>var baseURL="/",locationPathname="";baseURL=(locationPathname=document.location.pathname).substr(0,locationPathname.lastIndexOf("/")+1)</script><link rel="stylesheet" href="styles/clean-jsdoc-theme.min.css"><svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none"><defs><symbol id="copy-icon" viewbox="0 0 488.3 488.3"><g><path d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z"/><path d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z"/></g></symbol><symbol id="search-icon" viewBox="0 0 512 512"><g><g><path d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z"/></g></g><g><g><path d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z"/></g></g></symbol><symbol id="font-size-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11.246 15H4.754l-2 5H.6L7 4h2l6.4 16h-2.154l-2-5zm-.8-2L8 6.885 5.554 13h4.892zM21 12.535V12h2v8h-2v-.535a4 4 0 1 1 0-6.93zM19 18a2 2 0 1 0 0-4 2 2 0 0 0 0 4z"/></symbol><symbol id="add-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 11V5h2v6h6v2h-6v6h-2v-6H5v-2z"/></symbol><symbol id="minus-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M5 11h14v2H5z"/></symbol><symbol id="dark-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M10 7a7 7 0 0 0 12 4.9v.1c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2h.1A6.979 6.979 0 0 0 10 7zm-6 5a8 8 0 0 0 15.062 3.762A9 9 0 0 1 8.238 4.938 7.999 7.999 0 0 0 4 12z"/></symbol><symbol id="light-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 18a6 6 0 1 1 0-12 6 6 0 0 1 0 12zm0-2a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM11 1h2v3h-2V1zm0 19h2v3h-2v-3zM3.515 4.929l1.414-1.414L7.05 5.636 5.636 7.05 3.515 4.93zM16.95 18.364l1.414-1.414 2.121 2.121-1.414 1.414-2.121-2.121zm2.121-14.85l1.414 1.415-2.121 2.121-1.414-1.414 2.121-2.121zM5.636 16.95l1.414 1.414-2.121 2.121-1.414-1.414 2.121-2.121zM23 11v2h-3v-2h3zM4 11v2H1v-2h3z"/></symbol><symbol id="reset-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M18.537 19.567A9.961 9.961 0 0 1 12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10c0 2.136-.67 4.116-1.81 5.74L17 12h3a8 8 0 1 0-2.46 5.772l.997 1.795z"/></symbol><symbol id="down-icon" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"></path></symbol><symbol id="codepen-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M16.5 13.202L13 15.535v3.596L19.197 15 16.5 13.202zM14.697 12L12 10.202 9.303 12 12 13.798 14.697 12zM20 10.869L18.303 12 20 13.131V10.87zM19.197 9L13 4.869v3.596l3.5 2.333L19.197 9zM7.5 10.798L11 8.465V4.869L4.803 9 7.5 10.798zM4.803 15L11 19.131v-3.596l-3.5-2.333L4.803 15zM4 13.131L5.697 12 4 10.869v2.262zM2 9a1 1 0 0 1 .445-.832l9-6a1 1 0 0 1 1.11 0l9 6A1 1 0 0 1 22 9v6a1 1 0 0 1-.445.832l-9 6a1 1 0 0 1-1.11 0l-9-6A1 1 0 0 1 2 15V9z"/></symbol><symbol id="close-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 10.586l4.95-4.95 1.414 1.414-4.95 4.95 4.95 4.95-1.414 1.414-4.95-4.95-4.95 4.95-1.414-1.414 4.95-4.95-4.95-4.95L7.05 5.636z"/></symbol><symbol id="menu-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z"/></symbol></defs></svg></head><body data-theme="dark"><div class="sidebar-container"><div class="sidebar" id="sidebar"><a href="/" class="sidebar-title sidebar-title-anchor">Millicast SDK</a><div class="sidebar-items-container"><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-modules"><div>Modules</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="module-Director.html">Director</a></div><div class="sidebar-section-children"><a href="module-Logger.html">Logger</a></div><div class="sidebar-section-children"><a href="module-SdpParser.html">SdpParser</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-classes"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="BaseWebRTC.html">BaseWebRTC</a></div><div class="sidebar-section-children"><a href="PeerConnection.html">PeerConnection</a></div><div class="sidebar-section-children"><a href="Publish.html">Publish</a></div><div class="sidebar-section-children"><a href="Signaling.html">Signaling</a></div><div class="sidebar-section-children"><a href="View.html">View</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-events"><div>Events</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="BaseWebRTC.html#event:reconnect">reconnect</a></div><div class="sidebar-section-children"><a href="PeerConnection.html#event:connectionStateChange">connectionStateChange</a></div><div class="sidebar-section-children"><a href="PeerConnection.html#event:track">track</a></div><div class="sidebar-section-children"><a href="Publish.html#event:reconnect">reconnect</a></div><div class="sidebar-section-children"><a href="Signaling.html#event:broadcastEvent">broadcastEvent</a></div><div class="sidebar-section-children"><a href="Signaling.html#event:wsConnectionClose">wsConnectionClose</a></div><div class="sidebar-section-children"><a href="Signaling.html#event:wsConnectionError">wsConnectionError</a></div><div class="sidebar-section-children"><a href="Signaling.html#event:wsConnectionSuccess">wsConnectionSuccess</a></div><div class="sidebar-section-children"><a href="View.html#event:reconnect">reconnect</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-global"><div>Global</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="global.html#AudioCodec">AudioCodec</a></div><div class="sidebar-section-children"><a href="global.html#ConnectionStats">ConnectionStats</a></div><div class="sidebar-section-children"><a href="global.html#DRMOptions">DRMOptions</a></div><div class="sidebar-section-children"><a href="global.html#DirectorPublisherOptions">DirectorPublisherOptions</a></div><div class="sidebar-section-children"><a href="global.html#DirectorSubscriberOptions">DirectorSubscriberOptions</a></div><div class="sidebar-section-children"><a href="global.html#FrameMetaData">FrameMetaData</a></div><div class="sidebar-section-children"><a href="global.html#InboundStats">InboundStats</a></div><div class="sidebar-section-children"><a href="global.html#LayerInfo">LayerInfo</a></div><div class="sidebar-section-children"><a href="global.html#LayerInfo">LayerInfo</a></div><div class="sidebar-section-children"><a href="global.html#LogLevel">LogLevel</a></div><div class="sidebar-section-children"><a href="global.html#MillicastCapability">MillicastCapability</a></div><div class="sidebar-section-children"><a href="global.html#MillicastDirectorResponse">MillicastDirectorResponse</a></div><div class="sidebar-section-children"><a href="global.html#MillicastDirectorResponse">MillicastDirectorResponse</a></div><div class="sidebar-section-children"><a href="global.html#OutboundStats">OutboundStats</a></div><div class="sidebar-section-children"><a href="global.html#SEIPicTimingTimeCode">SEIPicTimingTimeCode</a></div><div class="sidebar-section-children"><a href="global.html#SEIUserUnregisteredData">SEIUserUnregisteredData</a></div><div class="sidebar-section-children"><a href="global.html#SignalingPublishOptions">SignalingPublishOptions</a></div><div class="sidebar-section-children"><a href="global.html#SignalingSubscribeOptions">SignalingSubscribeOptions</a></div><div class="sidebar-section-children"><a href="global.html#TrackReport">TrackReport</a></div><div class="sidebar-section-children"><a href="global.html#VideoCodec">VideoCodec</a></div><div class="sidebar-section-children"><a href="global.html#addPeerEvents">addPeerEvents</a></div><div class="sidebar-section-children"><a href="global.html#extractH26xMetadata">extractH26xMetadata</a></div><div class="sidebar-section-children"><a href="global.html#loggerHandler">loggerHandler</a></div><div class="sidebar-section-children"><a href="global.html#parseWebRTCStats">parseWebRTCStats</a></div><div class="sidebar-section-children"><a href="global.html#tokenGeneratorCallback">tokenGeneratorCallback</a></div></div></div></div></div><div class="navbar-container" id="VuAckcnZhf"><nav class="navbar"><div class="navbar-left-items"><div class="navbar-item"><a id="" href="https://github.com/millicast/millicast-sdk" target="_blank">Github</a></div><div class="navbar-item"><a id="" href="https://www.npmjs.com/package/@millicast/sdk" target="_blank">NPM Package</a></div></div><div class="navbar-right-items"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div><nav></nav></nav></div><div class="toc-container"><div class="toc-content"><span class="bold">On this page</span><div id="eed4d2a0bfd64539bb9df78095dec881"></div></div></div><div class="body-wrapper"><div class="main-content"><div class="main-wrapper"><section id="source-page" class="source-page"><header><h1 id="title" class="has-anchor">View.js</h1></header><article><pre class="prettyprint source lang-js"><code>import reemit from 're-emitter'
import jwtDecode from 'jwt-decode'
import Logger from './Logger'
import BaseWebRTC from './utils/BaseWebRTC'
import Signaling, { signalingEvents } from './Signaling'
import PeerConnection, { webRTCEvents } from './PeerConnection'
import { hexToUint8Array } from './utils/StringUtils'
import { swapPropertyValues } from './utils/ObjectUtils'
import FetchError from './utils/FetchError'
import { supportsInsertableStreams, supportsRTCRtpScriptTransform } from './utils/StreamTransform'
import { rtcDrmConfigure, rtcDrmOnTrack, rtcDrmEnvironments, rtcDrmFeedFrame } from './drm/rtc-drm-transform.js'
import TransformWorker from './workers/TransformWorker.worker.js?worker&amp;inline'
import SdpParser from './utils/SdpParser'

const logger = Logger.get('View')
logger.setLevel(Logger.DEBUG)

const connectOptions = {
  metadata: false,
  enableDRM: false,
  disableVideo: false,
  disableAudio: false,
  peerConfig: {
    autoInitStats: true,
    statsIntervalMs: 1000
  }
}

/**
 * @class View
 * @extends BaseWebRTC
 * @classdesc Manages connection with a secure WebSocket path to signal the Millicast server
 * and establishes a WebRTC connection to view a live stream.
 *
 * Before you can view an active broadcast, you will need:
 *
 * - A connection path that you can get from {@link Director} module or from your own implementation.
 * @constructor
 * @param {String} streamName - Deprecated: Millicast existing stream name.
 * @param {tokenGeneratorCallback} tokenGenerator - Callback function executed when a new token is needed.
 * @param {HTMLMediaElement} [mediaElement=null] - Deprecated: Target HTML media element to mount stream.
 * @param {Boolean} [autoReconnect=true] - Enable auto reconnect to stream.
 */
export default class View extends BaseWebRTC {
  constructor (streamName, tokenGenerator, mediaElement = null, autoReconnect = true) {
    if (streamName) {
      logger.warn('The streamName property has been deprecated. In a future release, this will be removed. Please do not rely on this value. Instead, set via token generator')
    }
    super(null, tokenGenerator, logger, autoReconnect)
    // States what payload type is associated with each codec from the SDP answer.
    this.payloadTypeCodec = {}
    // Follows the media id values of each transceiver's track from the 'track' events.
    this.tracksMidValues = {}
    // mapping media ID of RTCRtcTransceiver to DRM Options
    this.drmOptionsMap = null
    // cache of events to coordinate re-emitting
    this.eventQueue = []
    this.isMainStreamActive = false
    if (mediaElement) {
      logger.warn('The mediaElement property has been deprecated. In a future release, this will be removed. Please do not rely on this value. Instead, do this in either the `track` or the `active` broadcast event.')
    }
  }

  /**
   * @typedef {Object} LayerInfo
   * @property {String} encodingId         - rid value of the simulcast encoding of the track  (default: automatic selection)
   * @property {Number} spatialLayerId     - The spatial layer id to send to the outgoing stream (default: max layer available)
   * @property {Number} temporalLayerId    - The temporaral layer id to send to the outgoing stream (default: max layer available)
   * @property {Number} maxSpatialLayerId  - Max spatial layer id (default: unlimited)
   * @property {Number} maxTemporalLayerId - Max temporal layer id (default: unlimited)
   */

  /**
   * Connects to an active stream as subscriber.
   *
   * In the example, `addStreamToYourVideoTag` and `getYourSubscriberConnectionPath` is your own implementation.
   * @param {Object} [options]                          - General subscriber options.
   * @param {Boolean} [options.dtx = false]             - True to modify SDP for supporting dtx in opus. Otherwise False.
   * @param {Boolean} [options.absCaptureTime = false]  - True to modify SDP for supporting absolute capture time header extension. Otherwise False.
   * @param {Boolean} [options.metadata = false]        - Enable metadata extraction if stream is compatible.
   * @param {Boolean} [options.drm = false]             - Enable the DRM protected stream playback.
   * @param {Boolean} [options.disableVideo = false]    - Disable the opportunity to receive video stream.
   * @param {Boolean} [options.disableAudio = false]    - Disable the opportunity to receive audio stream.
   * @param {Number} [options.multiplexedAudioTracks]   - Number of audio tracks to recieve VAD multiplexed audio for secondary sources.
   * @param {String} [options.pinnedSourceId]           - Id of the main source that will be received by the default MediaStream.
   * @param {Array&lt;String>} [options.excludedSourceIds] - Do not receive media from the these source ids.
   * @param {Array&lt;String>} [options.events]            - Override which events will be delivered by the server (any of "active" | "inactive" | "vad" | "layers" | "viewercount" | "updated").*
   * @param {RTCConfiguration} [options.peerConfig]     - Options to configure the new RTCPeerConnection.
   * @param {LayerInfo} [options.layer]                 - Select the simulcast encoding layer and svc layers for the main video track, leave empty for automatic layer selection based on bandwidth estimation.
   * @param {Object} [options.forcePlayoutDelay = false]- Ask the server to use the playout delay header extension.
   * @param {Number} [options.forcePlayoutDelay.min]    - Set minimum playout delay value.
   * @param {Number} [options.forcePlayoutDelay.max]    - Set maximum playout delay value.
   * @param {Boolean} [options.enableDRM]               - Enable DRM, default is false.
   * @returns {Promise&lt;void>} Promise object which resolves when the connection was successfully established.
   * @fires PeerConnection#track
   * @fires Signaling#broadcastEvent
   * @fires PeerConnection#connectionStateChange
   * @example await millicastView.connect(options)
   * @example
   * import View from '@millicast/sdk'
   *
   * //Define callback for generate new token
   * const tokenGenerator = () => getYourSubscriberInformation(accountId, streamName)
   *
   * //Create a new instance
   * const streamName = "Millicast Stream Name where i want to connect"
   * const millicastView = new View(streamName, tokenGenerator)
   *
   * //Set track event handler to receive streams from Publisher.
   * millicastView.on('track', (event) => {
   *   addStreamToYourVideoTag(event.streams[0])
   * })
   *
   * millicastView.on('error', (error) => {
   *   console.error('Error from Millicast SDK', error)
   * })
   *
   * //Start connection to broadcast
   * try {
   *  await millicastView.connect()
   * } catch (e) {
   *  console.log('Connection failed, handle error', e)
   * }
   */
  async connect (options = connectOptions) {
    this.options = { ...connectOptions, ...options, peerConfig: { ...connectOptions.peerConfig, ...options.peerConfig }, setSDPToPeer: false }
    this.eventQueue.length = 0
    await this.initConnection({ migrate: false })
  }

  /**
   * Select the simulcast encoding layer and svc layers for the main video track
   * @param {LayerInfo} layer - leave empty for automatic layer selection based on bandwidth estimation.
   */
  async select (layer = {}) {
    logger.debug('Viewer select layer values: ', layer)
    await this.signaling.cmd('select', { layer })
    logger.info('Connected to streamName: ', this.streamName)
  }

  /**
   * Add remote receiving track.
   * @param {String} media - Media kind ('audio' | 'video').
   * @param {Array&lt;MediaStream>} streams - Streams the track will belong to.
   * @return {Promise&lt;RTCRtpTransceiver>} Promise that will be resolved when the RTCRtpTransceiver is assigned an mid value.
   */
  async addRemoteTrack (media, streams) {
    logger.info('Viewer adding remote track', media)
    const transceiver = await this.webRTCPeer.addRemoteTrack(media, streams)
    for (const stream of streams) {
      stream.addTrack(transceiver.receiver.track)
    }
    return transceiver
  }

  /**
   * Start projecting source in selected media ids.
   * @param {String} sourceId                          - Selected source id.
   * @param {Array&lt;Object>} mapping                    - Mapping of the source track ids to the receiver mids
   * @param {String} [mapping.trackId]                 - Track id from the source (received on the "active" event), if not set the media kind will be used instead.
   * @param {String} [mapping.media]                   - Track kind of the source ('audio' | 'video'), if not set the trackId will be used instead.
   * @param {String} [mapping.mediaId]                 - mid value of the rtp receiver in which the media is going to be projected. If no mediaId is defined, the first track from the main media stream with the same media type as the input source track will be used.
   * @param {LayerInfo} [mapping.layer]                - Select the simulcast encoding layer and svc layers, only applicable to video tracks.
   * @param {Boolean} [mapping.promote]                - To remove all existing limitations from the source, such as restricted bitrate or resolution, set this to true.
   */
  async project (sourceId, mapping) {
    for (const map of mapping) {
      if (!map.trackId &amp;&amp; !map.media) {
        logger.error('Error in projection mapping, trackId or mediaId must be set')
        throw new Error('Error in projection mapping, trackId or mediaId must be set')
      }
      const peer = this.webRTCPeer.getRTCPeer()
      // Check we have the mediaId in the transceivers
      if (map.mediaId &amp;&amp; !peer.getTransceivers().find(t => t.mid === map.mediaId.toString())) {
        logger.error(`Error in projection mapping, ${map.mediaId} mid not found in local transceivers`)
        throw new Error(`Error in projection mapping, ${map.mediaId} mid not found in local transceivers`)
      }
    }
    logger.debug('Viewer project source: layer mappings: ', sourceId, mapping)
    await this.signaling.cmd('project', { sourceId, mapping })
    logger.info('Projection done')
  }

  /**
   * Stop projecting attached source in selected media ids.
   * @param {Array&lt;String>} mediaIds - mid value of the receivers that are going to be detached.
   */
  async unproject (mediaIds) {
    logger.debug('Viewer unproject mediaIds: ', mediaIds)
    await this.signaling.cmd('unproject', { mediaIds })
    logger.info('Unprojection done')
  }

  async replaceConnection () {
    logger.info('Migrating current connection')
    await this.initConnection({ migrate: true })
  }

  stop () {
    super.stop()
    this.drmOptionsMap?.clear()
    this.DRMProfile = null
    this.worker?.terminate()
    this.worker = null
    this.payloadTypeCodec = {}
    this.tracksMidValues = {}
    this.eventQueue.length = 0
  }

  async initConnection (data) {
    logger.debug('Viewer connect options values: ', this.options)
    this.stopReconnection = false
    let promises
    if (!data.migrate &amp;&amp; this.isActive()) {
      logger.warn('Viewer currently subscribed')
      throw new Error('Viewer currently subscribed')
    }
    let subscriberData
    try {
      subscriberData = await this.tokenGenerator()
      // Set the iceServers from the subscribe data into the peerConfig
      this.options.peerConfig.iceServers = subscriberData?.iceServers
      // We should not set the encodedInsertableStreams if the DRM and the frame metadata are not enabled
      this.options.peerConfig.encodedInsertableStreams = supportsInsertableStreams &amp;&amp; (this.options.enableDRM || this.options.metadata)
    } catch (error) {
      // TODO: handle DRM error when DRM is enabled but no subscribe token is provided
      logger.error('Error generating token.')
      if (error instanceof FetchError) {
        if (error.status === 401 || !this.autoReconnect) {
          // should not reconnect
          this.stopReconnection = true
        } else {
          // should reconnect with exponential back off if autoReconnect is true
          this.reconnect()
        }
      }
      throw error
    }
    if (!subscriberData) {
      logger.error('Error while subscribing. Subscriber data required')
      throw new Error('Subscriber data required')
    }
    const decodedJWT = jwtDecode(subscriberData.jwt)
    this.streamName = decodedJWT.millicast.streamName
    const signalingInstance = new Signaling({
      streamName: this.streamName,
      url: `${subscriberData.urls[0]}?token=${subscriberData.jwt}`
    })
    if (subscriberData.subscriberToken) {
      this.subscriberToken = subscriberData.subscriberToken
    }
    const webRTCPeerInstance = data.migrate ? new PeerConnection() : this.webRTCPeer

    await webRTCPeerInstance.createRTCPeer(this.options.peerConfig)
    // Stop emiting events from the previous instances
    this.stopReemitingWebRTCPeerInstanceEvents?.()
    // And start emitting from the new ones
    this.stopReemitingWebRTCPeerInstanceEvents = reemit(webRTCPeerInstance, this, Object.values(webRTCEvents).filter(e => e !== webRTCEvents.track))

    if (this.options.metadata) {
      if (!this.worker) {
        this.worker = new TransformWorker()
      }
      this.worker.onmessage = (message) => {
        if (message.data.event === 'metadata') {
          const decoder = new TextDecoder()
          const metadata = message.data.metadata
          metadata.mid = message.data.mid
          metadata.track = this.tracksMidValues[message.data.mid]
          if (metadata.uuid) {
            const uuid = metadata.uuid
            metadata.uuid = uuid.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '')
            metadata.uuid = metadata.uuid.replace(/(.{8})(.{4})(.{4})(.{4})(.{12})/, '$1-$2-$3-$4-$5')
          }
          if (metadata.timecode) {
            metadata.timecode = new Date(decoder.decode(metadata.timecode))
          }
          if (metadata.unregistered) {
            const content = decoder.decode(metadata.unregistered)
            try {
              const json = JSON.parse(content)
              metadata.unregistered = json
            } catch (e) {
              // was not a JSON, just return the raw bytes (i.e. do nothing)
              logger.info('The content could not be converted to JSON, returning raw bytes instead')
            }
          }
          this.emit('metadata', metadata)
          // FIXME : Remove in v0.3.0
          this.emit('onMetadata', metadata)
        }
      }
    }

    webRTCPeerInstance.on(webRTCEvents.track, (trackEvent) => {
      if (!this.isMainStreamActive) {
        this.eventQueue.push(trackEvent)
        return
      }
      this.onTrackEvent(trackEvent)
    })

    signalingInstance.on(signalingEvents.broadcastEvent, async (event) => {
      if (!this.isMainStreamActive &amp;&amp; event.name === 'active') {
        // handle 'active' event for main stream
        this.mainSourceId = event.data.sourceId
        if (!this.DRMProfile &amp;&amp; event.data.encryption) {
          const subscriberData = await this.tokenGenerator()
          if (subscriberData.drmObject) {
            // cache the DRM license server URLs
            this.DRMProfile = subscriberData.drmObject
          }
        }
        this.emit(signalingEvents.broadcastEvent, event)
        this.isMainStreamActive = true
        while (this.eventQueue.length > 0) {
          this.onTrackEvent(this.eventQueue.shift())
        }
        return
      }
      if (event.name === 'inactive' &amp;&amp; this.isMainStreamActive &amp;&amp; this.mainSourceId === event.data.sourceId) {
        this.isMainStreamActive = false
      }
      this.emit(signalingEvents.broadcastEvent, event)
    })

    const getLocalSDPPromise = webRTCPeerInstance.getRTCLocalSDP({ ...this.options, stereo: true })
    const signalingConnectPromise = signalingInstance.connect()
    promises = await Promise.all([getLocalSDPPromise, signalingConnectPromise])
    const localSdp = promises[0]

    let oldSignaling = this.signaling
    this.signaling = signalingInstance

    const subscribePromise = this.signaling.subscribe(localSdp, { ...this.options, vad: this.options.multiplexedAudioTracks > 0 })
    const setLocalDescriptionPromise = webRTCPeerInstance.peer.setLocalDescription(webRTCPeerInstance.sessionDescription)
    promises = await Promise.all([subscribePromise, setLocalDescriptionPromise])
    const sdpSubscriber = promises[0]

    this.payloadTypeCodec = SdpParser.getCodecPayloadType(sdpSubscriber)

    await webRTCPeerInstance.setRTCRemoteSDP(sdpSubscriber)

    logger.info('Connected to streamName: ', this.streamName)

    let oldWebRTCPeer = this.webRTCPeer
    this.webRTCPeer = webRTCPeerInstance
    this.setReconnect()

    if (data.migrate) {
      this.webRTCPeer.on(webRTCEvents.connectionStateChange, (state) => {
        if (state === 'connected') {
          setTimeout(() => {
            oldSignaling?.close?.()
            oldWebRTCPeer?.closeRTCPeer?.()
            oldSignaling = oldWebRTCPeer = null
            logger.info('Current connection migrated')
          }, 1000)
        } else if (['disconnected', 'failed', 'closed'].includes(state)) {
          oldSignaling?.close?.()
          oldWebRTCPeer?.closeRTCPeer?.()
          oldSignaling = oldWebRTCPeer = null
        }
      })
    }
  }

  onTrackEvent (trackEvent) {
    this.tracksMidValues[trackEvent.transceiver?.mid] = trackEvent.track
    if (this.isDRMOn) {
      const mediaId = trackEvent.transceiver.mid
      const drmOptions = this.getDRMConfiguration(mediaId)
      try {
        rtcDrmOnTrack(trackEvent, drmOptions)
      } catch (error) {
        logger.error('Failed to apply DRM on media Id:', mediaId, 'error is: ', error)
        this.emit('error', new Error('Failed to apply DRM on media Id: ' + mediaId + ' error is: ' + error))
      }
      if (!this.worker) {
        this.worker = new TransformWorker()
      }
      this.worker.addEventListener('message', (message) => {
        if (message.data.event === 'complete') {
          // feed the frame to DRM processing worker
          rtcDrmFeedFrame(message.data.frame, null, drmOptions)
        }
      })
    }
    if (this.options.metadata) {
      if (supportsRTCRtpScriptTransform) {
        // eslint-disable-next-line no-undef
        trackEvent.receiver.transform = new RTCRtpScriptTransform(this.worker, {
          name: 'receiverTransform',
          payloadTypeCodec: { ...this.payloadTypeCodec },
          codec: this.options.metadata &amp;&amp; 'h264',
          mid: trackEvent.transceiver?.mid
        })
      } else if (supportsInsertableStreams) {
        const { readable, writable } = trackEvent.receiver.createEncodedStreams()
        this.worker.postMessage({
          action: 'insertable-streams-receiver',
          payloadTypeCodec: { ...this.payloadTypeCodec },
          codec: this.options.metadata &amp;&amp; 'h264',
          mid: trackEvent.transceiver?.mid,
          readable,
          writable
        }, [readable, writable])
      }
    }
    this.emit(webRTCEvents.track, trackEvent)
  }

  getDRMConfiguration (mediaId) {
    return this.drmOptionsMap ? this.drmOptionsMap.get(mediaId) : null
  }

  async onRtcDrmFetch (url, opts) {
    if (!opts.headers) {
      opts.headers = new Headers()
    }
    // our server doesn't support x-dt-custom-data
    if (opts.headers.get('x-dt-custom-data')) {
      opts.headers.delete('x-dt-custom-data')
    }
    if (this.subscriberToken) {
      opts.headers.append('Authorization', `Bearer ${this.subscriberToken}`)
    } else {
      logger.warn('onRtcDrmFetch: no subscriberToken')
    }
    return fetch(url, opts)
  }

  /**
   * @typedef {Object} EncryptionParameters
   * @property {String} keyId 16-byte KeyID, in lowercase hexadecimal without separators
   * @property {String} iv 16-byte initialization vector, in lowercase hexadecimal without separators
   * /

  /**
   * @typedef {Object} DRMOptions - the options for DRM playback
   * @property {HTMLVideoElement} videoElement - the video HTML element
   * @property {EncryptionParameters} videoEncryptionParams - the video encryption parameters
   * @property {String} videoMid - the video media ID of RTCRtpTransceiver
   * @property {HTMLAudioElement} audioElement - the audio HTML audioElement
   * @property {EncryptionParameters} [audioEncryptionParams] - the audio encryption parameters
   * @property {String} [audioMid] - the audio media ID of RTCRtpTransceiver
   * @property {Number} [mediaBufferMs] - average target latency in milliseconds
   */

  /**
   * Configure DRM protected stream.
   * When there are {@link EncryptionParameters} in the payload of 'active' broadcast event, this method should be called
   * @param {DRMOptions} options - the options for DRM playback
  */
  configureDRM (options) {
    if (!options) {
      throw new Error('Required DRM options is not provided')
    }
    if (!this.drmOptionsMap) {
      // map transceiver's mediaId to its DRM options
      this.drmOptionsMap = new Map()
    }
    const drmOptions = {
      merchant: 'dolby',
      environment: rtcDrmEnvironments.Production,
      customTransform: this.options.metadata,
      videoElement: options.videoElement,
      audioElement: options.audioElement,
      video: { codec: 'h264', encryption: 'cbcs', keyId: hexToUint8Array(options.videoEncryptionParams.keyId), iv: hexToUint8Array(options.videoEncryptionParams.iv) },
      audio: { codec: 'opus', encryption: 'clear' },
      onFetch: this.onRtcDrmFetch.bind(this)
    }
    if (options.mediaBufferMs) {
      drmOptions.mediaBufferMs = options.mediaBufferMs
    }
    if (this.DRMProfile) {
      if (this.DRMProfile.playReadyUrl) {
        drmOptions.prLicenseUrl = this.DRMProfile.playReadyUrl
      }
      if (this.DRMProfile.widevineUrl) {
        drmOptions.wvLicenseUrl = this.DRMProfile.widevineUrl
      }
      if (this.DRMProfile.fairPlayUrl) {
        drmOptions.fpsLicenseUrl = this.DRMProfile.fairPlayUrl
      }
      if (this.DRMProfile.fairPlayCertUrl) {
        drmOptions.fpsCertificateUrl = this.DRMProfile.fairPlayCertUrl
      }
    }
    try {
      rtcDrmConfigure(drmOptions)
      this.drmOptionsMap.set(options.videoMid, drmOptions)
      if (options.audioMid) {
        this.drmOptionsMap.set(options.audioMid, drmOptions)
      }
      drmOptions.videoElement.addEventListener('rtcdrmerror', (event) => {
        logger.error('DRM error: ', event.detail.message, 'in video element:', drmOptions.videoElement.id)
        this.emit('error', new Error(event.detail.message))
      })
    } catch (error) {
      logger.error('Failed to configure DRM with options:', options, 'error is:', error)
    }
  }

  /**
   * Remove DRM configuration for a mediaId
   * @param {String} mediaId
   */
  removeDRMConfiguration (mediaId) {
    this.drmOptionsMap?.delete(mediaId)
  }

  /**
   * Check if there are any DRM protected Track
   */
  get isDRMOn () {
    return !!this.drmOptionsMap &amp;&amp; this.drmOptionsMap.size > 0
  }

  /**
   * Exchange the DRM configuration between two transceivers
   * Both of the transceivers should be used for DRM protected streams
   * @param {String} targetMediaId
   * @param {String} sourceMediaId
   */
  exchangeDRMConfiguration (targetMediaId, sourceMediaId) {
    const targetDRMOptions = this.getDRMConfiguration(targetMediaId)
    const sourceDRMOptions = this.getDRMConfiguration(sourceMediaId)
    if (targetDRMOptions === null) {
      throw new Error('No DRM configuration found for ' + targetMediaId)
    }
    if (sourceDRMOptions === null) {
      throw new Error('No DRM configuration found for ' + sourceMediaId)
    }
    swapPropertyValues(targetDRMOptions.video, sourceDRMOptions.video, 'keyId')
    swapPropertyValues(targetDRMOptions.video, sourceDRMOptions.video, 'iv')
    try {
      rtcDrmConfigure(targetDRMOptions)
    } catch (error) {
      logger.error('Failed to configure DRM with options:', targetDRMOptions, 'error is:', error)
    }
    try {
      rtcDrmConfigure(sourceDRMOptions)
    } catch (error) {
      logger.error('Failed to configure DRM with options:', sourceDRMOptions, 'error is:', error)
    }
  }
}
</code></pre></article></section></div></div></div><div class="search-container" id="PkfLWpAbet" style="display:none"><div class="wrapper" id="iCxFxjkHbP"><button class="icon-button search-close-button" id="VjLlGakifb" aria-label="close search"><svg><use xlink:href="#close-icon"></use></svg></button><div class="search-box-c"><svg><use xlink:href="#search-icon"></use></svg> <input type="text" id="vpcKVYIppa" class="search-input" placeholder="Search..." autofocus></div><div class="search-result-c" id="fWwVHRuDuN"><span class="search-result-c-text">Type anything to view search result</span></div></div></div><div class="mobile-menu-icon-container"><button class="icon-button" id="mobile-menu" data-isopen="false" aria-label="menu"><svg><use xlink:href="#menu-icon"></use></svg></button></div><div id="mobile-sidebar" class="mobile-sidebar-container"><div class="mobile-sidebar-wrapper"><a href="/" class="sidebar-title sidebar-title-anchor">Millicast SDK</a><div class="mobile-nav-links"><div class="navbar-item"><a id="" href="https://github.com/millicast/millicast-sdk" target="_blank">Github</a></div><div class="navbar-item"><a id="" href="https://www.npmjs.com/package/@millicast/sdk" target="_blank">NPM Package</a></div></div><div class="mobile-sidebar-items-c"><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-modules"><div>Modules</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="module-Director.html">Director</a></div><div class="sidebar-section-children"><a href="module-Logger.html">Logger</a></div><div class="sidebar-section-children"><a href="module-SdpParser.html">SdpParser</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-classes"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="BaseWebRTC.html">BaseWebRTC</a></div><div class="sidebar-section-children"><a href="PeerConnection.html">PeerConnection</a></div><div class="sidebar-section-children"><a href="Publish.html">Publish</a></div><div class="sidebar-section-children"><a href="Signaling.html">Signaling</a></div><div class="sidebar-section-children"><a href="View.html">View</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-events"><div>Events</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="BaseWebRTC.html#event:reconnect">reconnect</a></div><div class="sidebar-section-children"><a href="PeerConnection.html#event:connectionStateChange">connectionStateChange</a></div><div class="sidebar-section-children"><a href="PeerConnection.html#event:track">track</a></div><div class="sidebar-section-children"><a href="Publish.html#event:reconnect">reconnect</a></div><div class="sidebar-section-children"><a href="Signaling.html#event:broadcastEvent">broadcastEvent</a></div><div class="sidebar-section-children"><a href="Signaling.html#event:wsConnectionClose">wsConnectionClose</a></div><div class="sidebar-section-children"><a href="Signaling.html#event:wsConnectionError">wsConnectionError</a></div><div class="sidebar-section-children"><a href="Signaling.html#event:wsConnectionSuccess">wsConnectionSuccess</a></div><div class="sidebar-section-children"><a href="View.html#event:reconnect">reconnect</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-global"><div>Global</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="global.html#AudioCodec">AudioCodec</a></div><div class="sidebar-section-children"><a href="global.html#ConnectionStats">ConnectionStats</a></div><div class="sidebar-section-children"><a href="global.html#DRMOptions">DRMOptions</a></div><div class="sidebar-section-children"><a href="global.html#DirectorPublisherOptions">DirectorPublisherOptions</a></div><div class="sidebar-section-children"><a href="global.html#DirectorSubscriberOptions">DirectorSubscriberOptions</a></div><div class="sidebar-section-children"><a href="global.html#FrameMetaData">FrameMetaData</a></div><div class="sidebar-section-children"><a href="global.html#InboundStats">InboundStats</a></div><div class="sidebar-section-children"><a href="global.html#LayerInfo">LayerInfo</a></div><div class="sidebar-section-children"><a href="global.html#LayerInfo">LayerInfo</a></div><div class="sidebar-section-children"><a href="global.html#LogLevel">LogLevel</a></div><div class="sidebar-section-children"><a href="global.html#MillicastCapability">MillicastCapability</a></div><div class="sidebar-section-children"><a href="global.html#MillicastDirectorResponse">MillicastDirectorResponse</a></div><div class="sidebar-section-children"><a href="global.html#MillicastDirectorResponse">MillicastDirectorResponse</a></div><div class="sidebar-section-children"><a href="global.html#OutboundStats">OutboundStats</a></div><div class="sidebar-section-children"><a href="global.html#SEIPicTimingTimeCode">SEIPicTimingTimeCode</a></div><div class="sidebar-section-children"><a href="global.html#SEIUserUnregisteredData">SEIUserUnregisteredData</a></div><div class="sidebar-section-children"><a href="global.html#SignalingPublishOptions">SignalingPublishOptions</a></div><div class="sidebar-section-children"><a href="global.html#SignalingSubscribeOptions">SignalingSubscribeOptions</a></div><div class="sidebar-section-children"><a href="global.html#TrackReport">TrackReport</a></div><div class="sidebar-section-children"><a href="global.html#VideoCodec">VideoCodec</a></div><div class="sidebar-section-children"><a href="global.html#addPeerEvents">addPeerEvents</a></div><div class="sidebar-section-children"><a href="global.html#extractH26xMetadata">extractH26xMetadata</a></div><div class="sidebar-section-children"><a href="global.html#loggerHandler">loggerHandler</a></div><div class="sidebar-section-children"><a href="global.html#parseWebRTCStats">parseWebRTCStats</a></div><div class="sidebar-section-children"><a href="global.html#tokenGeneratorCallback">tokenGeneratorCallback</a></div></div></div><div class="mobile-navbar-actions"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div></div></div><script type="text/javascript" src="scripts/core.min.js"></script><script src="scripts/search.min.js" defer="defer"></script><script src="scripts/third-party/fuse.js" defer="defer"></script><script type="text/javascript">var tocbotInstance=tocbot.init({tocSelector:"#eed4d2a0bfd64539bb9df78095dec881",contentSelector:".main-content",headingSelector:"h1, h2, h3",hasInnerContainers:!0,scrollContainer:".main-content",headingsOffset:130,onClick:bringLinkToView})</script></body></html>